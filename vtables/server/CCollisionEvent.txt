VTable for CCollisionEvent:
    [0] CCollisionEvent::PostCollision(vcollisionevent_t*)
    [1] CCollisionEvent::Friction(IPhysicsObject*, float, int, int, IPhysicsCollisionData*)
    [2] CCollisionEvent::StartTouch(IPhysicsObject*, IPhysicsObject*, IPhysicsCollisionData*)
    [3] CCollisionEvent::EndTouch(IPhysicsObject*, IPhysicsObject*, IPhysicsCollisionData*)
    [4] CCollisionEvent::FluidStartTouch(IPhysicsObject*, IPhysicsFluidController*)
    [5] CCollisionEvent::FluidEndTouch(IPhysicsObject*, IPhysicsFluidController*)
    [6] CCollisionEvent::PostSimulationFrame()
    [7] CCollisionEvent::ObjectEnterTrigger(IPhysicsObject*, IPhysicsObject*)
    [8] CCollisionEvent::ObjectLeaveTrigger(IPhysicsObject*, IPhysicsObject*)
    [9] CCollisionEvent::AddDamageEvent(CBaseEntity*, CTakeDamageInfo const&, IPhysicsObject*, bool, Vector const&, Vector const&)
    [10] CCollisionEvent::ShouldCollide(IPhysicsObject*, IPhysicsObject*, void*, void*)
    [11] CCollisionEvent::ShouldSolvePenetration(IPhysicsObject*, IPhysicsObject*, void*, void*, float)
    [12] CCollisionEvent::ShouldFreezeObject(IPhysicsObject*)
    [13] CCollisionEvent::AdditionalCollisionChecksThisTick(int)
    [14] CCollisionEvent::ShouldFreezeContacts(IPhysicsObject**, int)
    [15] CCollisionEvent::ObjectWake(IPhysicsObject*)
    [16] CCollisionEvent::ObjectSleep(IPhysicsObject*)
